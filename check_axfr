#!/usr/bin/perl -w
#
# Copyright (C) 1998 David Eckelkamp
#           (C) 2005 Ondrej Sury
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

require 5.004;
use strict;
use Getopt::Long;
use English;
use File::Basename qw(basename);
use Net::DNS;

my ($opt_c, $opt_w, $opt_V, $opt_h, $opt_H, $opt_z, $opt_M, $opt_t, $opt_r, $verbose);
use lib "/usr/lib/nagios/plugins";
use utils qw($TIMEOUT %ERRORS &print_revision &support);

my $PROGNAME = basename($PROGRAM_NAME);
my $VERSION = '0.2.0';

$ENV{'PATH'}='';
$ENV{'BASH_ENV'}='';
$ENV{'ENV'}='';

Getopt::Long::Configure('bundling');
GetOptions
	("V"   => \$opt_V, "version"    => \$opt_V,
	 "h"   => \$opt_h, "help"       => \$opt_h,
	 "v" => \$verbose, "verbose"  	=> \$verbose,
         "w=o" => \$opt_w, "warning"    => \$opt_w,
         "c=o" => \$opt_c, "critical"   => \$opt_c,
	 "r=s" => \$opt_r, "retries=f"  => \$opt_r,
	 "z=s" => \$opt_z, "zone=s"     => \$opt_z,
	 "M=s" => \$opt_M, "master=s"   => \$opt_M,
	 "t=s" => \$opt_t, "timeout=i"  => \$opt_t,
	 "H=s" => \$opt_H, "hostname=s" => \$opt_H);

if ($opt_V) {
    print_revision($PROGNAME,'$Revision: 0.01 $ ');
    exit $ERRORS{'OK'};
}

if ($opt_h) {
    print_help();
    exit $ERRORS{'OK'};
}

$opt_H = shift unless ($opt_H);
my $host = $1 if ($opt_H && $opt_H =~ m/^([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+|[a-zA-Z][-a-zA-Z0-9]+(\.[a-zA-Z][-a-zA-Z0-9]+)*)$/);
unless ($host) {
    print "No target host specified\n";
    print_usage();
    exit $ERRORS{'UNKNOWN'};
}

my ($timeout, $retries);

$timeout = $TIMEOUT;
($opt_t) && ($opt_t =~ /^([0-9]+)$/) && ($timeout = $1);

$retries = 2;
($opt_r) && ($opt_r =~ /^([0-9]+)$/) && ($retries = $1);

my $zone = $opt_z;
unless ($zone) {
    print "No zone specified\n";
    print_usage();
    exit $ERRORS{'UNKNOWN'};
}

my $master = $opt_M;
unless ($master) {
    print "No master DNS server specified\n";
    print_usage();
    exit $ERRORS{'UNKNOWN'};
}

$opt_c ||= 0;
$opt_w = $opt_c if not defined $opt_w;
if ($opt_w > $opt_c) {
    print "Warning level higher than critical level; ignoring.\n";
    $opt_w = $opt_c;
}

my $master_serial = get_serial($zone, $master, $retries, $timeout);
my $master_serial_critical  = $master_serial - $opt_c;
my $master_serial_warn      = $master_serial - $opt_w;

my $slave_serial = get_serial($zone, $host, $retries, $timeout);

if ($master_serial != $slave_serial) {
    my $should_be_text;
    my $err = $ERRORS{'OK'};

    if ( $slave_serial < $master_serial_critical ) {
        $err = $ERRORS{'CRITICAL'};
        $should_be_text = ($opt_c)
                        ? "${master_serial} - ${master_serial_critical}"
                        : $master_serial;
    }
    elsif ( $slave_serial < $master_serial_warn ) {
        $err = $ERRORS{'WARNING'};
        $should_be_text = ($opt_w)
                        ? "${master_serial} - ${master_serial_warn}"
                        : $master_serial;
    }

    if ($err != $ERRORS{'OK'}) {
        print "Serial not up-to-date: is ${slave_serial}, should be ${should_be_text}\n";
        exit $err;
    }
}

print "Serial for $zone: $master_serial\n";
exit $ERRORS{"OK"};

#### subs

sub get_serial {
    my ($zone, $ns, $retries, $timeout) = @_;

    my $res = new Net::DNS::Resolver;
    $res->defnames(0);
    $res->recurse(0);
    $res->retry($retries);
    $res->nameservers($ns);
    my $soa_req = $res->query($zone, "SOA");

    if (!defined($soa_req) || ($soa_req->header->ancount <= 0)) {
        print "SOA query for zone '$zone' to nameserver '$ns' failed (" . $res->errorstring . ")\n";
        exit $ERRORS{'UNKNOWN'};
    }

    unless ($soa_req->header->aa) {
        print "$ns in not authoritative for $zone\n";
        exit $ERRORS{'UNKNOWN'};
    }

    unless ($soa_req->header->ancount == 1) {
        print "Too many answers for SOA query from $ns for $zone\n";
        exit $ERRORS{'UNKNOWN'};
    }

    unless (($soa_req->answer)[0]->type eq "SOA") {
        print "Query for SOA for $zone from $ns failed: return type = ". ($soa_req->answer)[0]->type . "\n";
        exit $ERRORS{'UNKNOWN'};
    }

    my $serial = ($soa_req->answer)[0]->serial();

    return $serial;
}

sub print_usage {
    print "Usage: $PROGNAME -H <host> [ -c <lag_critical> [ -w <lag_warning> ] ] [-r <retries>] -M <master> -z <zone> [-v verbose]\n";
}

sub print_help {
    print_revision($PROGNAME, "$VERSION");
    print "Copyright (c) 2003 Ondrej Sury, 2012 Wil Cooley\n";
    print "\n";
    print_usage();
    support();
}
